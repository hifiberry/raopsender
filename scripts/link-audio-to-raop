#!/usr/bin/env bash
set -euo pipefail

# link-audio-to-raop
# Links the HiFiBerry ADC input to the selected RAOP sink
# Reads the target sink from ~/.config/raop-sink-name

########################################
# Configuration
########################################
CONFIG_FILE="$HOME/.config/raop-sink-name"
LOG_TAG="raop-audio-link"

# Function to log messages
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$LOG_TAG] $1"
}

########################################
# Check prerequisites
########################################
if ! command -v pw-link >/dev/null 2>&1; then
    log_message "ERROR: pw-link not found. Please install PipeWire tools."
    exit 1
fi

if ! command -v pw-cli >/dev/null 2>&1; then
    log_message "ERROR: pw-cli not found. Please install PipeWire."
    exit 1
fi

# Check if PipeWire is running
if ! pw-cli info >/dev/null 2>&1; then
    log_message "ERROR: PipeWire is not running or accessible."
    exit 1
fi

# Check if config file exists
if [ ! -f "$CONFIG_FILE" ]; then
    log_message "ERROR: Configuration file not found: $CONFIG_FILE"
    log_message "Please run select-raop-sink script first to choose a target sink."
    exit 1
fi

########################################
# Read target sink
########################################
TARGET_SINK=$(cat "$CONFIG_FILE" | tr -d '\n' | xargs)

if [ -z "$TARGET_SINK" ]; then
    log_message "ERROR: No target sink specified in $CONFIG_FILE"
    exit 1
fi

log_message "Target RAOP sink: $TARGET_SINK"

########################################
# Wait for audio devices to be ready
########################################
log_message "Waiting 5 seconds for audio devices to initialize..."
sleep 5

########################################
# Find HiFiBerry ADC input
########################################
log_message "Searching for HiFiBerry ADC input..."

# Get all nodes and find HiFiBerry input source
all_nodes=$(pw-cli ls Node)

if [ -z "$all_nodes" ]; then
    log_message "ERROR: Could not get node list from PipeWire."
    exit 1
fi

# Parse nodes to find HiFiBerry input
HIFIBERRY_INPUT=""
current_name=""
current_description=""
current_media_class=""

while IFS= read -r line; do
    # Check for start of new node
    if [[ $line =~ ^[[:space:]]*id[[:space:]]+[0-9]+.*type[[:space:]]+PipeWire:Interface:Node ]]; then
        # Check if previous node was a HiFiBerry input
        # Look for either "HiFiBerry" in description OR "platform-soc_sound" in node name (which indicates HiFiBerry on Pi)
        if [[ "$current_media_class" == "Audio/Source" ]] && [ -n "$current_name" ] && (
            [[ "$current_description" =~ [Hh]ifi[Bb]erry ]] || 
            [[ "$current_name" =~ platform-soc_sound ]] ||
            [[ "$current_name" =~ sndrpihifiberry ]]
        ); then
            HIFIBERRY_INPUT="$current_name"
            break
        fi
        
        # Reset for new node
        current_name=""
        current_description=""
        current_media_class=""
    elif [[ $line =~ ^[[:space:]]*node\.name[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
        current_name="${BASH_REMATCH[1]}"
    elif [[ $line =~ ^[[:space:]]*node\.description[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
        current_description="${BASH_REMATCH[1]}"
    elif [[ $line =~ ^[[:space:]]*media\.class[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
        current_media_class="${BASH_REMATCH[1]}"
    fi
done <<< "$all_nodes"

# Check the last node too
if [ -z "$HIFIBERRY_INPUT" ] && [[ "$current_media_class" == "Audio/Source" ]] && [ -n "$current_name" ] && (
    [[ "$current_description" =~ [Hh]ifi[Bb]erry ]] || 
    [[ "$current_name" =~ platform-soc_sound ]] ||
    [[ "$current_name" =~ sndrpihifiberry ]]
); then
    HIFIBERRY_INPUT="$current_name"
fi

if [ -z "$HIFIBERRY_INPUT" ]; then
    log_message "ERROR: Could not find HiFiBerry ADC input device."
    log_message "Available audio sources:"
    # Show all audio sources for debugging
    while IFS= read -r line; do
        if [[ $line =~ ^[[:space:]]*id[[:space:]]+[0-9]+.*type[[:space:]]+PipeWire:Interface:Node ]]; then
            current_name=""
            current_description=""
            current_media_class=""
        elif [[ $line =~ ^[[:space:]]*node\.name[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
            current_name="${BASH_REMATCH[1]}"
        elif [[ $line =~ ^[[:space:]]*node\.description[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
            current_description="${BASH_REMATCH[1]}"
        elif [[ $line =~ ^[[:space:]]*media\.class[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
            current_media_class="${BASH_REMATCH[1]}"
            if [[ "$current_media_class" == "Audio/Source" ]] && [ -n "$current_name" ] && [ -n "$current_description" ]; then
                log_message "  - $current_description ($current_name)"
            fi
        fi
    done <<< "$all_nodes"
    exit 1
fi

log_message "Found HiFiBerry input: $HIFIBERRY_INPUT"

########################################
# Verify target sink exists
########################################
log_message "Verifying target RAOP sink exists..."

if ! pw-cli ls Node | grep -q "node.name = \"$TARGET_SINK\""; then
    log_message "ERROR: Target sink not found: $TARGET_SINK"
    log_message "Available RAOP sinks:"
    pw-cli ls Node | grep -A 2 'media.class = "Audio/Sink"' | grep 'raop_sink' | grep 'node.name\|node.description'
    exit 1
fi

log_message "Target sink verified: $TARGET_SINK"

# Get the numeric ID for potential wpctl usage
SINK_ID=$(pw-cli ls Node | grep -B 5 "node.name = \"$TARGET_SINK\"" | grep "id " | head -1 | sed 's/.*id \([0-9]*\).*/\1/')
if [ -n "$SINK_ID" ]; then
    log_message "Target sink ID: $SINK_ID (for wpctl commands)"
fi

########################################
# Create audio link
########################################
log_message "Creating audio link from $HIFIBERRY_INPUT to $TARGET_SINK..."

# Extract ports using pw-cli output - use port IDs directly
log_message "Finding port IDs using pw-cli ls Port..."

# Get node IDs using a more robust method
log_message "Searching for HiFiBerry node ID..."
HIFIBERRY_NODE_ID=$(pw-cli ls Node | awk '
    /^[[:space:]]*id [0-9]+/ { 
        match($0, /id ([0-9]+)/, arr); 
        current_id = arr[1]; 
        node_name = ""; 
        media_class = "" 
    }
    /node\.name = "'"$HIFIBERRY_INPUT"'"/ { node_name = "'"$HIFIBERRY_INPUT"'" }
    /media\.class = "Audio\/Source"/ { media_class = "Audio/Source" }
    (media_class == "Audio/Source") && (node_name == "'"$HIFIBERRY_INPUT"'") { print current_id; exit }
')
log_message "HiFiBerry node ID: $HIFIBERRY_NODE_ID"

# Get RAOP sink node ID
log_message "Searching for RAOP sink node ID..."
RAOP_NODE_ID=$(pw-cli ls Node | awk '
    /^[[:space:]]*id [0-9]+/ { 
        match($0, /id ([0-9]+)/, arr); 
        current_id = arr[1]; 
        node_name = ""; 
        media_class = "" 
    }
    /node\.name = "'"$TARGET_SINK"'"/ { node_name = "'"$TARGET_SINK"'" }
    /media\.class = "Audio\/Sink"/ { media_class = "Audio/Sink" }
    (media_class == "Audio/Sink") && (node_name == "'"$TARGET_SINK"'") { print current_id; exit }
')
log_message "RAOP sink node ID: $RAOP_NODE_ID"

if [ -z "$HIFIBERRY_NODE_ID" ] || [ -z "$RAOP_NODE_ID" ]; then
    log_message "ERROR: Could not find node IDs"
    log_message "Available Audio/Source nodes:"
    pw-cli ls Node | awk '
        /^[[:space:]]*id [0-9]+/ { current_id = $2; node_name = ""; node_desc = "" }
        /node\.name = / { match($0, /node\.name = "([^"]*)"/, arr); node_name = arr[1] }
        /node\.description = / { match($0, /node\.description = "([^"]*)"/, arr); node_desc = arr[1] }
        /media\.class = "Audio\/Source"/ { print "  ID " current_id ": " node_desc " (" node_name ")" }
    '
    log_message "Available Audio/Sink nodes:"
    pw-cli ls Node | awk '
        /^[[:space:]]*id [0-9]+/ { current_id = $2; node_name = ""; node_desc = "" }
        /node\.name = / { match($0, /node\.name = "([^"]*)"/, arr); node_name = arr[1] }
        /node\.description = / { match($0, /node\.description = "([^"]*)"/, arr); node_desc = arr[1] }
        /media\.class = "Audio\/Sink"/ && node_name ~ /raop_sink/ { print "  ID " current_id ": " node_desc " (" node_name ")" }
    '
    exit 1
fi

# Get capture port IDs (direction "out") for HiFiBerry - exclude monitor ports
log_message "Searching for HiFiBerry capture ports..."
INPUT_PORT_IDS=$(pw-cli ls Port | awk -v target_node="$HIFIBERRY_NODE_ID" '
    /^[[:space:]]*id [0-9]+/ { 
        match($0, /id ([0-9]+)/, arr); 
        current_id = arr[1]; 
        node_id = ""; 
        direction = ""; 
        is_monitor = 0; 
        has_audio_channel = 0 
    }
    /node\.id = / { match($0, /node\.id = "([^"]*)"/, arr); node_id = arr[1] }
    /port\.direction = / { match($0, /port\.direction = "([^"]*)"/, arr); direction = arr[1] }
    /port\.monitor = "true"/ { is_monitor = 1 }
    /audio\.channel/ { has_audio_channel = 1 }
    (node_id == target_node) && (direction == "out") && (is_monitor == 0) && (has_audio_channel == 1) { 
        print current_id 
    }
')

# Get send port IDs (direction "in") for RAOP sink
log_message "Searching for RAOP sink input ports..."
SINK_PORT_IDS=$(pw-cli ls Port | awk -v target_node="$RAOP_NODE_ID" '
    /^[[:space:]]*id [0-9]+/ { 
        match($0, /id ([0-9]+)/, arr); 
        current_id = arr[1]; 
        node_id = ""; 
        direction = ""; 
        is_monitor = 0; 
        has_audio_channel = 0 
    }
    /node\.id = / { match($0, /node\.id = "([^"]*)"/, arr); node_id = arr[1] }
    /port\.direction = / { match($0, /port\.direction = "([^"]*)"/, arr); direction = arr[1] }
    /port\.monitor = "true"/ { is_monitor = 1 }
    /audio\.channel/ { has_audio_channel = 1 }
    (node_id == target_node) && (direction == "in") && (is_monitor == 0) && (has_audio_channel == 1) { 
        print current_id 
    }
')

log_message "Found HiFiBerry port IDs: $INPUT_PORT_IDS"
log_message "Found RAOP sink port IDs: $SINK_PORT_IDS"

INPUT_PORTS="$INPUT_PORT_IDS"
SINK_PORTS="$SINK_PORT_IDS"

if [ -z "$INPUT_PORTS" ]; then
    log_message "ERROR: No output ports found for $HIFIBERRY_INPUT (node ID: $HIFIBERRY_NODE_ID)"
    log_message "Available ports for node $HIFIBERRY_NODE_ID:"
    pw-cli ls Port | grep -A 10 "node.id = \"$HIFIBERRY_NODE_ID\"" | grep -E "(port.name|port.direction|audio.channel)" || log_message "  No ports found"
    exit 1
fi

if [ -z "$SINK_PORTS" ]; then
    log_message "ERROR: No input ports found for $TARGET_SINK (node ID: $RAOP_NODE_ID)"
    log_message "Available ports for node $RAOP_NODE_ID:"
    pw-cli ls Port | grep -A 10 "node.id = \"$RAOP_NODE_ID\"" | grep -E "(port.name|port.direction|audio.channel)" || log_message "  No ports found"
    exit 1
fi

# Convert to arrays
IFS=$'\n' read -d '' -r -a input_array <<< "$INPUT_PORTS" || true
IFS=$'\n' read -d '' -r -a sink_array <<< "$SINK_PORTS" || true

log_message "Found ${#input_array[@]} output ports and ${#sink_array[@]} input ports"

# Link ports (typically left to left, right to right) using port IDs
for i in "${!input_array[@]}"; do
    if [ $i -lt ${#sink_array[@]} ]; then
        input_port_id="${input_array[i]}"
        sink_port_id="${sink_array[i]}"
        
        log_message "Linking port IDs: $input_port_id -> $sink_port_id"
        
        if pw-link "$input_port_id" "$sink_port_id"; then
            log_message "Successfully linked port $((i+1))"
        else
            log_message "WARNING: Failed to link port $((i+1))"
        fi
    fi
done

########################################
# Verify connections
########################################
log_message "Verifying audio connections..."
connected_links=$(pw-link -l | grep -c "$HIFIBERRY_INPUT.*$TARGET_SINK" || true)

if [ "$connected_links" -gt 0 ]; then
    log_message "SUCCESS: Audio link established ($connected_links connections active)"
    log_message "HiFiBerry ADC input is now streaming to RAOP sink"
else
    log_message "WARNING: No active connections detected"
fi

log_message "Audio linking completed."