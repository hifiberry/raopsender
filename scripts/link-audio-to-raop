#!/usr/bin/env bash
set -euo pipefail

# link-audio-to-raop
# Links the HiFiBerry ADC input to the selected RAOP sink
# Reads the target sink from ~/.config/raop-sink-name

########################################
# Configuration
########################################
CONFIG_FILE="$HOME/.config/raop-sink-name"
LOG_TAG="raop-audio-link"

# Function to log messages
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$LOG_TAG] $1"
}

########################################
# Check prerequisites
########################################
if ! command -v pw-link >/dev/null 2>&1; then
    log_message "ERROR: pw-link not found. Please install PipeWire tools."
    exit 1
fi

if ! command -v pw-cli >/dev/null 2>&1; then
    log_message "ERROR: pw-cli not found. Please install PipeWire."
    exit 1
fi

# Check if PipeWire is running
if ! pw-cli info >/dev/null 2>&1; then
    log_message "ERROR: PipeWire is not running or accessible."
    exit 1
fi

# Check if config file exists
if [ ! -f "$CONFIG_FILE" ]; then
    log_message "ERROR: Configuration file not found: $CONFIG_FILE"
    log_message "Please run select-raop-sink script first to choose a target sink."
    exit 1
fi

########################################
# Read target sink
########################################
TARGET_SINK=$(cat "$CONFIG_FILE" | tr -d '\n' | xargs)

if [ -z "$TARGET_SINK" ]; then
    log_message "ERROR: No target sink specified in $CONFIG_FILE"
    exit 1
fi

log_message "Target RAOP sink: $TARGET_SINK"

########################################
# Wait for audio devices to be ready
########################################
log_message "Waiting 5 seconds for audio devices to initialize..."
sleep 5

########################################
# Find HiFiBerry ADC input
########################################
log_message "Searching for HiFiBerry ADC input..."

# Get all nodes and find HiFiBerry input source
all_nodes=$(pw-cli ls Node)

if [ -z "$all_nodes" ]; then
    log_message "ERROR: Could not get node list from PipeWire."
    exit 1
fi

# Parse nodes to find HiFiBerry input
HIFIBERRY_INPUT=""
current_name=""
current_description=""
current_media_class=""

while IFS= read -r line; do
    # Check for start of new node
    if [[ $line =~ ^[[:space:]]*id[[:space:]]+[0-9]+.*type[[:space:]]+PipeWire:Interface:Node ]]; then
        # Check if previous node was a HiFiBerry input
        # Look for either "HiFiBerry" in description OR "platform-soc_sound" in node name (which indicates HiFiBerry on Pi)
        if [[ "$current_media_class" == "Audio/Source" ]] && [ -n "$current_name" ] && (
            [[ "$current_description" =~ [Hh]ifi[Bb]erry ]] || 
            [[ "$current_name" =~ platform-soc_sound ]] ||
            [[ "$current_name" =~ sndrpihifiberry ]]
        ); then
            HIFIBERRY_INPUT="$current_name"
            break
        fi
        
        # Reset for new node
        current_name=""
        current_description=""
        current_media_class=""
    elif [[ $line =~ ^[[:space:]]*node\.name[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
        current_name="${BASH_REMATCH[1]}"
    elif [[ $line =~ ^[[:space:]]*node\.description[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
        current_description="${BASH_REMATCH[1]}"
    elif [[ $line =~ ^[[:space:]]*media\.class[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
        current_media_class="${BASH_REMATCH[1]}"
    fi
done <<< "$all_nodes"

# Check the last node too
if [ -z "$HIFIBERRY_INPUT" ] && [[ "$current_media_class" == "Audio/Source" ]] && [ -n "$current_name" ] && (
    [[ "$current_description" =~ [Hh]ifi[Bb]erry ]] || 
    [[ "$current_name" =~ platform-soc_sound ]] ||
    [[ "$current_name" =~ sndrpihifiberry ]]
); then
    HIFIBERRY_INPUT="$current_name"
fi

if [ -z "$HIFIBERRY_INPUT" ]; then
    log_message "ERROR: Could not find HiFiBerry ADC input device."
    log_message "Available audio sources:"
    # Show all audio sources for debugging
    while IFS= read -r line; do
        if [[ $line =~ ^[[:space:]]*id[[:space:]]+[0-9]+.*type[[:space:]]+PipeWire:Interface:Node ]]; then
            current_name=""
            current_description=""
            current_media_class=""
        elif [[ $line =~ ^[[:space:]]*node\.name[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
            current_name="${BASH_REMATCH[1]}"
        elif [[ $line =~ ^[[:space:]]*node\.description[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
            current_description="${BASH_REMATCH[1]}"
        elif [[ $line =~ ^[[:space:]]*media\.class[[:space:]]*=[[:space:]]*\"(.*)\" ]]; then
            current_media_class="${BASH_REMATCH[1]}"
            if [[ "$current_media_class" == "Audio/Source" ]] && [ -n "$current_name" ] && [ -n "$current_description" ]; then
                log_message "  - $current_description ($current_name)"
            fi
        fi
    done <<< "$all_nodes"
    exit 1
fi

log_message "Found HiFiBerry input: $HIFIBERRY_INPUT"

########################################
# Verify target sink exists
########################################
log_message "Verifying target RAOP sink exists..."

if ! pw-cli ls Node | grep -q "node.name = \"$TARGET_SINK\""; then
    log_message "ERROR: Target sink not found: $TARGET_SINK"
    log_message "Available RAOP sinks:"
    pw-cli ls Node | grep -A 2 'media.class = "Audio/Sink"' | grep 'raop_sink' | grep 'node.name\|node.description'
    exit 1
fi

log_message "Target sink verified: $TARGET_SINK"

# Get the numeric ID for potential wpctl usage
SINK_ID=$(pw-cli ls Node | grep -B 5 "node.name = \"$TARGET_SINK\"" | grep "id " | head -1 | sed 's/.*id \([0-9]*\).*/\1/')
if [ -n "$SINK_ID" ]; then
    log_message "Target sink ID: $SINK_ID (for wpctl commands)"
fi

########################################
# Create audio link
########################################
log_message "Creating audio link from $HIFIBERRY_INPUT to $TARGET_SINK..."

# First check if pw-link -l returns anything at all
log_message "Checking if any ports are available..."
all_ports=$(pw-link -l)
if [ -z "$all_ports" ]; then
    log_message "No ports found with pw-link -l. Checking with pw-cli ls Port..."
    
    # Try using pw-cli ls Port instead
    port_info=$(pw-cli ls Port)
    if [ -z "$port_info" ]; then
        log_message "ERROR: No audio ports found. Audio devices may not be ready."
        log_message "Try waiting longer or check if audio devices are properly initialized."
        exit 1
    fi
    
    # Extract ports using pw-cli output - use port IDs directly
    log_message "Finding port IDs using pw-cli ls Port..."
    
    # Get output port IDs for HiFiBerry input (capture ports with direction "out")
    # Find the node.id for our HiFiBerry input first
    HIFIBERRY_NODE_ID=$(pw-cli ls Node | grep -B 5 "node.name = \"$HIFIBERRY_INPUT\"" | grep "id " | head -1 | sed 's/.*id \([0-9]*\).*/\1/')
    log_message "HiFiBerry node ID: $HIFIBERRY_NODE_ID"
    
    # Get RAOP sink node ID
    RAOP_NODE_ID=$(pw-cli ls Node | grep -B 5 "node.name = \"$TARGET_SINK\"" | grep "id " | head -1 | sed 's/.*id \([0-9]*\).*/\1/')
    log_message "RAOP sink node ID: $RAOP_NODE_ID"
    
    if [ -z "$HIFIBERRY_NODE_ID" ] || [ -z "$RAOP_NODE_ID" ]; then
        log_message "ERROR: Could not find node IDs"
        exit 1
    fi
    
    # Get capture port IDs (direction "out") for HiFiBerry - exclude monitor ports
    INPUT_PORT_IDS=$(pw-cli ls Port | awk -v node_id="$HIFIBERRY_NODE_ID" '
        /^[[:space:]]*id [0-9]+/ { current_id = $2; node_matches = 0; is_out = 0; is_monitor = 0 }
        /node\.id = "'"$HIFIBERRY_NODE_ID"'"/ { node_matches = 1 }
        /port\.direction = "out"/ { is_out = 1 }
        /port\.monitor = "true"/ { is_monitor = 1 }
        node_matches && is_out && !is_monitor && /audio\.channel/ { print current_id }
    ')
    
    # Get send port IDs (direction "in") for RAOP sink
    SINK_PORT_IDS=$(pw-cli ls Port | awk -v node_id="$RAOP_NODE_ID" '
        /^[[:space:]]*id [0-9]+/ { current_id = $2; node_matches = 0; is_in = 0; is_monitor = 0 }
        /node\.id = "'"$RAOP_NODE_ID"'"/ { node_matches = 1 }
        /port\.direction = "in"/ { is_in = 1 }
        /port\.monitor = "true"/ { is_monitor = 1 }
        node_matches && is_in && !is_monitor && /audio\.channel/ { print current_id }
    ')
    
    INPUT_PORTS="$INPUT_PORT_IDS"
    SINK_PORTS="$SINK_PORT_IDS"
    
else
    log_message "Found ports with pw-link -l, using standard method..."
    
    # Get the output ports of the HiFiBerry input (typically stereo: left and right)
    log_message "Searching for output ports of $HIFIBERRY_INPUT..."
    INPUT_PORTS=$(echo "$all_ports" | grep "$HIFIBERRY_INPUT" | grep "output" | awk '{print $1}')

    # Get the input ports of the target sink
    log_message "Searching for input ports of $TARGET_SINK..."
    SINK_PORTS=$(echo "$all_ports" | grep "$TARGET_SINK" | grep "input" | awk '{print $1}')
fi

if [ -z "$INPUT_PORTS" ]; then
    log_message "ERROR: No output ports found for $HIFIBERRY_INPUT"
    log_message "Available ports for HiFiBerry input:"
    pw-cli ls Port | grep -A 10 "$HIFIBERRY_INPUT" || log_message "  No ports found at all"
    log_message "All available ports:"
    pw-cli ls Port | grep "port.name" | head -10 || log_message "  No ports found"
    exit 1
fi

if [ -z "$SINK_PORTS" ]; then
    log_message "ERROR: No input ports found for $TARGET_SINK"
    log_message "Available ports for RAOP sink:"
    pw-cli ls Port | grep -A 10 "$TARGET_SINK" || log_message "  No ports found at all"
    exit 1
fi

# Convert to arrays
IFS=$'\n' read -d '' -r -a input_array <<< "$INPUT_PORTS" || true
IFS=$'\n' read -d '' -r -a sink_array <<< "$SINK_PORTS" || true

log_message "Found ${#input_array[@]} output ports and ${#sink_array[@]} input ports"

# Link ports (typically left to left, right to right) using port IDs
for i in "${!input_array[@]}"; do
    if [ $i -lt ${#sink_array[@]} ]; then
        input_port_id="${input_array[i]}"
        sink_port_id="${sink_array[i]}"
        
        log_message "Linking port IDs: $input_port_id -> $sink_port_id"
        
        if pw-link "$input_port_id" "$sink_port_id"; then
            log_message "Successfully linked port $((i+1))"
        else
            log_message "WARNING: Failed to link port $((i+1))"
        fi
    fi
done

########################################
# Verify connections
########################################
log_message "Verifying audio connections..."
connected_links=$(pw-link -l | grep -c "$HIFIBERRY_INPUT.*$TARGET_SINK" || true)

if [ "$connected_links" -gt 0 ]; then
    log_message "SUCCESS: Audio link established ($connected_links connections active)"
    log_message "HiFiBerry ADC input is now streaming to RAOP sink"
else
    log_message "WARNING: No active connections detected"
fi

log_message "Audio linking completed."